// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id               String    @id @default(cuid())
  name             String?
  email            String    @unique
  emailVerified    DateTime?
  image            String?
  phone            String?
  password         String?
  resetToken       String?
  resetTokenExpiry DateTime?
  role             UserRole  @default(CUSTOMER)
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  // Email verification for garage owners
  emailVerificationCode   String?
  emailVerificationExpiry DateTime?

  // Review ratings
  averageRating Float @default(0)
  totalReviews  Int   @default(0)

  accounts         Account[]
  sessions         Session[]
  vehicles         Vehicle[]
  bookings         Booking[]
  garage           Garage?
  reviews          Review[]
  motNotifications MotNotification[]
  garageApprovals  GarageApprovalLog[] @relation("ApprovedByAdmin")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Garage {
  id          String   @id @default(cuid())
  name        String
  email       String   @unique
  phone       String
  address     String
  city        String
  postcode    String
  latitude    Float?
  longitude   Float?
  description String?
  website     String?
  isActive    Boolean  @default(false) // Inactive by default, activated after approval
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // MOT Testing Authorization
  motLicenseNumber String  @unique
  dvlaApproved     Boolean @default(false)

  // Admin Approval Status
  approvalStatus  GarageApprovalStatus @default(PENDING)
  approvedAt      DateTime?
  approvedById    String?
  rejectionReason String?

  // Business Hours
  openingHours Json? // Store as JSON: {"monday": {"open": "09:00", "close": "17:00"}, ...}

  // Pricing
  motPrice    Float @default(54.85) // Maximum MOT price in UK
  retestPrice Float @default(27.43) // Partial retest price

  // Review ratings
  averageRating Float @default(0)
  totalReviews  Int   @default(0)

  // MOT booking quota (purchased packages of 10)
  motQuota           Int                       @default(0)

  // Relations
  ownerId            String                    @unique
  owner              User                      @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  bookings           Booking[]
  reviews            Review[]
  schedules          GarageSchedule[]
  scheduleExceptions GarageScheduleException[]
  timeSlotBlocks     GarageTimeSlotBlock[]
  approvalLogs       GarageApprovalLog[]
  purchaseRequests   PurchaseRequest[]
}

// GarageAvailability model removed - replaced by optimized system
// using GarageSchedule, GarageScheduleException, and GarageTimeSlotBlock

model Vehicle {
  id           String   @id @default(cuid())
  registration String
  make         String
  model        String
  year         Int
  color        String?
  fuelType     FuelType
  engineSize   String?
  mileage      Int?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  ownerId          String
  owner            User              @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  bookings         Booking[]
  motHistory       MotHistory[]
  motNotifications MotNotification[]

  // Composite unique constraint: same user cannot register same vehicle twice
  // But different users can register vehicles with the same registration number
  @@unique([registration, ownerId], name: "unique_vehicle_per_user")
}

model Booking {
  id         String        @id @default(cuid())
  bookingRef String        @unique @default(cuid())
  date       DateTime
  timeSlot   String
  status     BookingStatus @default(PENDING)
  totalPrice Float
  notes      String?
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt

  // Relations
  customerId String
  customer   User    @relation(fields: [customerId], references: [id], onDelete: Cascade)
  garageId   String
  garage     Garage  @relation(fields: [garageId], references: [id], onDelete: Cascade)
  vehicleId  String
  vehicle    Vehicle @relation(fields: [vehicleId], references: [id], onDelete: Cascade)

  // Payment
  paymentStatus         PaymentStatus @default(PENDING)
  stripePaymentIntentId String?
  paidAt                DateTime?

  // MOT Result
  motResult       MotResult?
  reviews         Review[]
  emailLogs       EmailLog[]
  scheduledEmails ScheduledEmail[]
}

model MotResult {
  id                String     @id @default(cuid())
  bookingId         String     @unique
  result            MotOutcome
  certificateNumber String?    @unique
  expiryDate        DateTime?
  mileage           Int?
  advisories        String? // JSON string of advisory items
  minorDefects      String? // JSON string of minor defects
  majorDefects      String? // JSON string of major defects
  dangerousDefects  String? // JSON string of dangerous defects
  testDate          DateTime   @default(now())
  createdAt         DateTime   @default(now())

  booking Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)
}

model MotHistory {
  id                 String     @id @default(cuid())
  vehicleId          String
  testDate           DateTime
  result             MotOutcome
  certificateNumber  String?
  expiryDate         DateTime?
  mileage            Int?
  odometerUnit       String? // MI or KM
  odometerResultType String? // READ, UNREADABLE, NOT_AVAILABLE
  testLocation       String?
  testNumber         String?    @unique
  dataSource         String? // DVSA or other source

  // Defect counts
  dangerousDefects Int @default(0)
  majorDefects     Int @default(0)
  minorDefects     Int @default(0)
  advisoryDefects  Int @default(0)
  prsDefects       Int @default(0) // PRS = Presented for Rectification

  // Defect details (JSON array of defect objects)
  defectDetails String? // JSON string of defect details

  // Vehicle info at time of test
  registrationAtTimeOfTest String?

  // Additional metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  vehicle Vehicle @relation(fields: [vehicleId], references: [id], onDelete: Cascade)
}

model Review {
  id           String       @id @default(cuid())
  rating       Int // 1-5 stars
  comment      String?
  reviewerType ReviewerType // CUSTOMER or GARAGE
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt

  // Relations
  customerId String
  customer   User    @relation(fields: [customerId], references: [id], onDelete: Cascade)
  garageId   String
  garage     Garage  @relation(fields: [garageId], references: [id], onDelete: Cascade)
  bookingId  String
  booking    Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  // Ensure only one review per booking per reviewer type (allows both customer AND garage to review same booking)
  @@unique([bookingId, reviewerType])
}

model MotNotification {
  id              String           @id @default(cuid())
  vehicleId       String
  userId          String
  type            NotificationType // EXPIRING_SOON, EXPIRED, FAILED
  title           String
  message         String
  daysUntilExpiry Int?
  isRead          Boolean          @default(false)
  sentAt          DateTime         @default(now())
  readAt          DateTime?
  createdAt       DateTime         @default(now())

  // Relations
  vehicle Vehicle @relation(fields: [vehicleId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isRead])
  @@index([vehicleId])
}

enum NotificationType {
  EXPIRING_SOON
  EXPIRED
  FAILED
}

enum ReviewerType {
  CUSTOMER
  GARAGE
}

// Enums
enum UserRole {
  CUSTOMER
  GARAGE_OWNER
  ADMIN
}

enum GarageApprovalStatus {
  PENDING
  APPROVED
  REJECTED
  INFO_REQUESTED
}

enum FuelType {
  PETROL
  DIESEL
  ELECTRIC
  HYBRID
  LPG
  OTHER
}

enum BookingStatus {
  PENDING
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  NO_SHOW
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  REFUNDED
}

enum MotOutcome {
  PASS
  FAIL
  REFUSED
}

// Optimized model for garage opening hours
model GarageSchedule {
  id                 String   @id @default(cuid())
  garageId           String
  dayOfWeek          Int // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
  isOpen             Boolean  @default(true)
  openTime           String // e.g., "09:00"
  closeTime          String // e.g., "17:00"
  slotDuration       Int      @default(30) // Duration in minutes (30 = 30 minute slots)
  maxBookingsPerSlot Int      @default(1) // Allow multiple bookings per slot if needed
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  garage Garage @relation(fields: [garageId], references: [id], onDelete: Cascade)

  @@unique([garageId, dayOfWeek])
}

// Model for schedule exceptions (holidays, special days)
model GarageScheduleException {
  id        String   @id @default(cuid())
  garageId  String
  date      DateTime // Specific date of the exception
  isClosed  Boolean  @default(true) // If true, garage is closed on this day
  openTime  String? // Special opening time (if not closed)
  closeTime String? // Special closing time (if not closed)
  reason    String? // Reason for exception (holiday, maintenance, etc.)
  createdAt DateTime @default(now())

  garage Garage @relation(fields: [garageId], references: [id], onDelete: Cascade)

  @@unique([garageId, date])
}

// Simplified model for specific time slot blocks
model GarageTimeSlotBlock {
  id        String   @id @default(cuid())
  garageId  String
  date      DateTime
  timeSlot  String // e.g., "09:00"
  reason    String? // Reason for blocking
  createdAt DateTime @default(now())

  garage Garage @relation(fields: [garageId], references: [id], onDelete: Cascade)

  @@unique([garageId, date, timeSlot])
}

// Garage approval/rejection history log
model GarageApprovalLog {
  id        String               @id @default(cuid())
  garageId  String
  action    GarageApprovalStatus
  reason    String? // Reason for action (required for rejection)
  adminId   String
  createdAt DateTime             @default(now())

  garage Garage @relation(fields: [garageId], references: [id], onDelete: Cascade)
  admin  User   @relation("ApprovedByAdmin", fields: [adminId], references: [id])

  @@index([garageId])
}

// Email logs for tracking email delivery
model EmailLog {
  id             String      @id @default(cuid())
  bookingId      String?
  recipientEmail String
  recipientName  String?
  emailType      EmailType
  subject        String
  status         EmailStatus @default(PENDING)
  errorMessage   String?
  retryCount     Int         @default(0)
  sentAt         DateTime?
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  booking Booking? @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  @@index([bookingId])
  @@index([recipientEmail])
  @@index([status])
  @@index([emailType])
  @@index([createdAt])
}

// Scheduled email reminders
model ScheduledEmail {
  id           String             @id @default(cuid())
  bookingId    String
  emailType    ScheduledEmailType
  scheduledFor DateTime // When to send the email
  status       ScheduledStatus    @default(PENDING)
  sentAt       DateTime?
  errorMessage String?
  retryCount   Int                @default(0)
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt

  booking Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  @@unique([bookingId, emailType])
  @@index([bookingId])
  @@index([scheduledFor])
  @@index([status])
}

enum EmailType {
  BOOKING_CONFIRMATION_CUSTOMER
  BOOKING_NOTIFICATION_GARAGE
  BOOKING_APPROVED
  BOOKING_REJECTED
  BOOKING_REMINDER_1_MONTH
  BOOKING_REMINDER_1_WEEK
  BOOKING_REMINDER_1_DAY
  BOOKING_COMPLETED_FOLLOWUP
  PURCHASE_REQUEST_NOTIFICATION
  GARAGE_VALIDATION_REQUEST
  PURCHASE_APPROVED
  PURCHASE_REJECTED
}

enum EmailStatus {
  PENDING
  SENT
  FAILED
  BOUNCED
}

enum ScheduledEmailType {
  REMINDER_1_MONTH
  REMINDER_1_WEEK
  REMINDER_1_DAY
}

enum ScheduledStatus {
  PENDING
  SENT
  FAILED
  CANCELLED
}

// MOT booking purchase request (bank transfer flow or Stripe)
model PurchaseRequest {
  id              String                @id @default(cuid())
  garageId        String
  bankReference   String                // garage ID + timestamp format (or Stripe session id for Stripe payments)
  amountPence    Int                   // 1000 = Â£10
  quantity        Int                   @default(10) // 10 MOT bookings per package
  status          PurchaseRequestStatus @default(PENDING)
  requestedAt     DateTime              @default(now())
  approvedAt      DateTime?
  rejectedAt      DateTime?
  rejectionReason String?
  approvedById    String?
  stripeSessionId String?               // Stripe Checkout Session ID for audit and idempotency

  garage   Garage                    @relation(fields: [garageId], references: [id], onDelete: Cascade)
  auditLogs PurchaseRequestAuditLog[]

  @@index([garageId])
  @@index([status])
  @@index([requestedAt])
  @@index([stripeSessionId])
}

enum PurchaseRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

// Write-only audit log for purchase request actions
model PurchaseRequestAuditLog {
  id               String         @id @default(cuid())
  purchaseRequestId String
  action           String         // APPROVED | REJECTED
  performedById   String
  performedAt     DateTime       @default(now())
  details         String?        // optional JSON or rejection reason

  purchaseRequest PurchaseRequest @relation(fields: [purchaseRequestId], references: [id], onDelete: Cascade)

  @@index([purchaseRequestId])
  @@index([performedAt])
}

// In-app notifications for super-admins (purchase requests, garage validation)
model AdminNotification {
  id          String   @id @default(cuid())
  type        AdminNotificationType
  referenceId String   // purchaseRequestId or garageId
  title       String
  message     String
  readAt      DateTime?
  createdAt   DateTime @default(now())

  @@index([type])
  @@index([readAt])
  @@index([createdAt])
}

enum AdminNotificationType {
  GARAGE_PENDING
  GARAGE_VALIDATION
  MOT_PURCHASE_REQUEST
}
